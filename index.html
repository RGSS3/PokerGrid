<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="/icon.png" />
    <title>九宫牌</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE',
                    }
                }
            }
        }
    </script>
    <style>
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }
        
        .card-fade-in {
            animation: fadeIn 0.3s ease-in-out;
        }
        
        .card-fade-out {
            animation: fadeOut 0.3s ease-in-out;
        }
        
        .card {
            aspect-ratio: 2/3;
            perspective: 1000px;
        }
        
        .card-inner {
            transform-style: preserve-3d;
            transition: transform 0.6s;
        }
        
        .card-front, .card-back {
            backface-visibility: hidden;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 0.5rem;
        }
        
        .card-back {
            transform: rotateY(180deg);
            background-image: repeating-linear-gradient(45deg, rgba(93, 92, 222, 0.1) 0, rgba(93, 92, 222, 0.1) 10px, transparent 10px, transparent 20px);
        }
        
        .dark .card-back {
            background-image: repeating-linear-gradient(45deg, rgba(93, 92, 222, 0.2) 0, rgba(93, 92, 222, 0.2) 10px, transparent 10px, transparent 20px);
        }
        
        /* 花色颜色定义 */
        .heart {
            color: #E53E3E; /* 红色 */
        }
        
        .dark .heart {
            color: #FC8181; /* 深色模式下的红色 */
        }
        
        .diamond {
            color: #ED8936; /* 橙色 */
        }
        
        .dark .diamond {
            color: #F6AD55; /* 深色模式下的橙色 */
        }
        
        .spade {
            color: #805AD5; /* 紫色 */
        }
        
        .dark .spade {
            color: #9F7AEA; /* 深色模式下的紫色 */
        }
        
        .club {
            color: #2D3748; /* 深灰色/黑色 */
        }
        
        .dark .club {
            color: #E2E8F0; /* 深色模式下的灰白色 */
        }
        
        /* Ensure all inputs have at least 16px font size on mobile */
        @media (max-width: 768px) {
            input, button, select, textarea {
                font-size: 16px !important;
            }
        }
        
        /* Disable text selection for the game interface */
        body {
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        
        /* Re-enable text selection for input elements */
        input, textarea {
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
        }
    </style>
</head>
<body class="bg-white dark:bg-gray-900 text-gray-900 dark:text-gray-100 min-h-screen">
    <div class="container mx-auto px-4 py-8 max-w-3xl">
        <!-- Language Selector -->
        <div class="flex justify-end mb-4 items-center">
            <label for="language-selector" class="mr-2 text-gray-700 dark:text-gray-300 text-sm">Language:</label>
            <div class="relative w-48">
                <select id="language-selector" class="block appearance-none w-full bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 hover:border-gray-400 px-4 py-2 pr-8 rounded shadow leading-tight focus:outline-none focus:shadow-outline">
                    <!-- Language options will be populated here -->
                </select>
                <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-700 dark:text-gray-300">
                    <svg class="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg>
                </div>
            </div>
        </div>
        
        <div class="text-center mb-6">
            <h1 class="text-3xl font-bold mb-2" data-i18n="gameTitle"></h1>
            <p class="text-sm md:text-base text-gray-600 dark:text-gray-400 mb-1" data-i18n="gameDescription"></p>
            <p class="text-xs md:text-sm text-gray-500 dark:text-gray-500 mb-1" data-i18n="comboDescription"></p>
            <p class="text-sm text-gray-500 dark:text-gray-500">
                <span data-i18n="remainingCards"></span>: <span id="remaining-cards" class="font-semibold">52</span> | 
                <span data-i18n="score"></span>: <span id="score" class="font-semibold">0</span>
            </p>
        </div>
        
        <!-- Random Seed Display -->
        <div class="mb-4 flex justify-center">
            <div class="flex flex-col sm:flex-row items-center text-sm bg-gray-100 dark:bg-gray-800 rounded-lg p-2">
                <span class="mr-2 mb-1 sm:mb-0" data-i18n="randomSeed"></span>
                <code id="seed-display" class="bg-gray-200 dark:bg-gray-700 px-2 py-1 rounded text-xs sm:text-sm break-all"></code>
                <button id="random-seed" class="ml-1 mt-1 sm:mt-0 text-primary hover:text-primary-dark px-1 py-1 rounded text-xs">🎲</button>
                <button id="copy-seed" class="ml-2 mt-1 sm:mt-0 text-primary hover:text-primary-dark px-2 py-1 rounded text-xs">📋 <span data-i18n="copy"></span></button>
                <button id="share-game" class="ml-2 mt-1 sm:mt-0 text-primary hover:text-primary-dark px-2 py-1 rounded text-xs">↗️ <span data-i18n="share"></span></button>
                <button id="restart-game" class="ml-2 mt-1 sm:mt-0 bg-yellow-500 hover:bg-yellow-600 text-white px-2 py-1 rounded text-xs">🔄 <span data-i18n="restart"></span></button>
                <button id="new-game-btn" class="ml-2 mt-1 sm:mt-0 bg-primary hover:bg-primary-600 text-white px-2 py-1 rounded text-xs">➕ <span data-i18n="newGame"></span></button>
            </div>
        </div>

        <!-- Seed Input for Starting Specific Game -->
        <div class="mb-4 flex justify-center">
            <div class="flex flex-col sm:flex-row items-center text-sm">
                <input type="text" id="seed-input" class="px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 w-full sm:w-auto mb-2 sm:mb-0" data-i18n-placeholder="enterSeed">
                <button id="start-from-seed" class="bg-primary hover:bg-primary-600 text-white px-4 py-2 rounded-lg ml-0 sm:ml-2" data-i18n="start"></button>
            </div>
        </div>

        <!-- Game Container with Card Counter -->
        <div class="flex flex-col md:flex-row mb-6 justify-center items-start gap-4">
            <!-- Game Playing Area (left) -->
            <div class="flex flex-col items-center">
                <!-- Current Card Display -->
                <div class="mb-6 flex justify-center">
                    <div class="text-center">
                        <p class="text-sm mb-2" data-i18n="currentCard"></p>
                        <div id="current-card" class="card w-16 h-24 md:w-20 md:h-30 mx-auto bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded-lg shadow-md flex items-center justify-center text-lg md:text-xl font-bold">
                            <div class="card-inner">
                                <div class="card-front flex items-center justify-center">
                                    <span>?</span>
                                </div>
                                <div class="card-back"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Game Grid -->
                <div class="grid grid-cols-3 gap-2 md:gap-3 mb-6 max-w-xs mx-auto">
                    <!-- Grid cells will be dynamically generated here -->
                </div>
            </div>
            
            <!-- Card Counter (right) -->
            <div class="flex-shrink-0 w-full md:w-auto bg-white dark:bg-gray-800 rounded-lg p-3 shadow-md border border-gray-300 dark:border-gray-700">
                <h3 class="text-sm font-semibold mb-2 text-center text-gray-700 dark:text-gray-300" data-i18n="remainingDeck"></h3>
                <div id="card-counter" class="grid grid-cols-4 gap-1 text-center">
                    <!-- Card counter will be dynamically generated here -->
                </div>
            </div>
        </div>

        <!-- Game Messages -->
        <div id="message-area" class="text-center mb-4 h-12 flex items-center justify-center">
            <p id="game-message" class="text-sm md:text-base font-medium"></p>
        </div>
        
        <!-- Game Log -->
        <div class="mb-4 max-w-md mx-auto">
            <h3 class="text-sm font-semibold mb-2 text-gray-700 dark:text-gray-300" data-i18n="clearingRecord"></h3>
            <div id="game-log" class="bg-gray-100 dark:bg-gray-800 rounded-lg p-3 h-32 overflow-y-auto text-sm">
                <div class="space-y-1"></div>
            </div>
        </div>

        <!-- Game Result Modal (hidden by default) -->
        <div id="result-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
            <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-md w-full mx-4">
                <h2 class="text-2xl font-bold mb-4 text-center" data-i18n="gameOver"></h2>
                <p class="text-lg mb-2"><span data-i18n="finalScore"></span>: <span id="final-score" class="font-bold"></span></p>
                <p class="mb-4 text-sm text-gray-600 dark:text-gray-400" data-i18n="playAgainPrompt"></p>
                <div class="flex flex-wrap justify-center gap-2">
                    <button id="play-again" class="bg-primary hover:bg-primary-600 text-white px-4 py-2 rounded-lg" data-i18n="newGame"></button>
                    <button id="replay-same-seed" class="bg-yellow-500 hover:bg-yellow-600 text-white px-4 py-2 rounded-lg" data-i18n="replaySameSeed"></button>
                    <button id="share-result" class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg" data-i18n="shareResult"></button>
                </div>
            </div>
        </div>
        
        <!-- Toast Notification (for copy feedback) -->
        <div id="toast" class="fixed bottom-4 left-1/2 transform -translate-x-1/2 bg-gray-800 text-white px-4 py-2 rounded-lg opacity-0 transition-opacity duration-300 z-50">
            <!-- Toast content will be set dynamically -->
        </div>

        <script>
            // Multi-language support
            const LANGUAGES = {
                'zh-CN': {
                    name: '中文',
                    gameTitle: '九宫牌',
                    gameDescription: '形成同花(50分)、顺子(100分)、三条(100分)或同花顺(200分)来消除行、列或对角线',
                    comboDescription: '同时消除：2连×2倍、3连×4倍、4连×8倍',
                    remainingCards: '剩余牌数',
                    score: '得分',
                    randomSeed: '随机种子',
                    copy: '复制',
                    share: '分享',
                    restart: '重开',
                    newGame: '新游戏',
                    enterSeed: '输入种子开始特定游戏',
                    start: '开始',
                    currentCard: '当前牌',
                    remainingDeck: '牌组剩余情况',
                    clearingRecord: '消除记录',
                    gameOver: '游戏结束!',
                    finalScore: '最终得分',
                    playAgainPrompt: '再来一局，挑战更高分!',
                    replaySameSeed: '重玩本局',
                    shareResult: '分享成绩',
                    copied: '已复制到剪贴板',
                    shareFailed: '分享失败，请手动复制',
                    shareText: '我正在https://poe.com/pokergrid玩九宫牌，获得了{score}分的好成绩，随机种子是{seed}，你也来和我一起玩吧！',
                    comboClearing: '{count}连消除! ({multiplier}倍分数)',
                    patternPoints: '{pattern}! +{points}分',
                    cleared: '消除',
                    singlePattern: '消除 {pattern} [{cards}] = {points}分',
                    multiplePattern: '{count}连消除! ({multiplier}) = {points}分',
                    gameOverMessage: '游戏结束！',
                    // Card pattern names
                    'flush': '同花',
                    'straight': '顺子',
                    'threeOfAKind': '三条',
                    'straightFlush': '同花顺'
                },
                'ja': {
                    name: '日本語',
                    gameTitle: '九宮牌',
                    gameDescription: 'フラッシュ(50点)、ストレート(100点)、スリーカード(100点)またはストレートフラッシュ(200点)を形成して行、列または対角線を消去',
                    comboDescription: '同時消去：2連×2倍、3連×4倍、4連×8倍',
                    remainingCards: '残りカード',
                    score: 'スコア',
                    randomSeed: 'ランダムシード',
                    copy: 'コピー',
                    share: 'シェア',
                    restart: 'リスタート',
                    newGame: '新規ゲーム',
                    enterSeed: '特定のゲームを開始するためのシードを入力',
                    start: '開始',
                    currentCard: '現在のカード',
                    remainingDeck: 'デッキの残りカード',
                    clearingRecord: '消去記録',
                    gameOver: 'ゲーム終了!',
                    finalScore: '最終スコア',
                    playAgainPrompt: 'もう一度プレイして高得点に挑戦！',
                    replaySameSeed: '同じラウンドを再プレイ',
                    shareResult: '結果をシェア',
                    copied: 'クリップボードにコピーしました',
                    shareFailed: 'シェアに失敗しました、手動でコピーしてください',
                    shareText: '私はhttps://poe.com/pokergridで九宮牌を{score}点という好成績でプレイしています。ランダムシードは{seed}です。一緒にプレイしませんか！',
                    comboClearing: '{count}連続消去! ({multiplier}倍ポイント)',
                    patternPoints: '{pattern}! +{points}点',
                    cleared: '消去',
                    singlePattern: '{pattern}を消去 [{cards}] = {points}点',
                    multiplePattern: '{count}連続消去! ({multiplier}) = {points}点',
                    gameOverMessage: 'ゲーム終了！',
                    // Card pattern names
                    'flush': 'フラッシュ',
                    'straight': 'ストレート',
                    'threeOfAKind': 'スリーカード',
                    'straightFlush': 'ストレートフラッシュ'
                },
                'ko': {
                    name: '한국어',
                    gameTitle: '구궁 카드',
                    gameDescription: '플러시(50점), 스트레이트(100점), 트리플(100점) 또는 스트레이트 플러시(200점)를 형성하여 행, 열 또는 대각선 제거',
                    comboDescription: '동시 제거: 2연속×2배, 3연속×4배, 4연속×8배',
                    remainingCards: '남은 카드',
                    score: '점수',
                    randomSeed: '랜덤 시드',
                    copy: '복사',
                    share: '공유',
                    restart: '다시 시작',
                    newGame: '새 게임',
                    enterSeed: '특정 게임을 시작할 시드 입력',
                    start: '시작',
                    currentCard: '현재 카드',
                    remainingDeck: '남은 덱 상황',
                    clearingRecord: '제거 기록',
                    gameOver: '게임 종료!',
                    finalScore: '최종 점수',
                    playAgainPrompt: '다시 한 번 도전하여 더 높은 점수를 노려보세요!',
                    replaySameSeed: '같은 라운드 다시 플레이',
                    shareResult: '결과 공유',
                    copied: '클립보드에 복사됨',
                    shareFailed: '공유 실패, 수동으로 복사해주세요',
                    shareText: '저는 https://poe.com/pokergrid에서 구궁 카드를 플레이하여 {score}점의 좋은 성적을 얻었습니다. 랜덤 시드는 {seed}입니다. 함께 플레이해보세요!',
                    comboClearing: '{count}연속 제거! ({multiplier}배 점수)',
                    patternPoints: '{pattern}! +{points}점',
                    cleared: '제거',
                    singlePattern: '{pattern} 제거 [{cards}] = {points}점',
                    multiplePattern: '{count}연속 제거! ({multiplier}) = {points}점',
                    gameOverMessage: '게임 종료!',
                    // Card pattern names
                    'flush': '플러시',
                    'straight': '스트레이트',
                    'threeOfAKind': '트리플',
                    'straightFlush': '스트레이트 플러시'
                },
                'en': {
                    name: 'English',
                    gameTitle: 'Grid Poker',
                    gameDescription: 'Form Flush (50pts), Straight (100pts), Three of a Kind (100pts) or Straight Flush (200pts) to clear rows, columns or diagonals',
                    comboDescription: 'Simultaneous clearing: 2 patterns ×2, 3 patterns ×4, 4 patterns ×8',
                    remainingCards: 'Cards left',
                    score: 'Score',
                    randomSeed: 'Random Seed',
                    copy: 'Copy',
                    share: 'Share',
                    restart: 'Restart',
                    newGame: 'New Game',
                    enterSeed: 'Enter seed to start specific game',
                    start: 'Start',
                    currentCard: 'Current Card',
                    remainingDeck: 'Remaining Cards in Deck',
                    clearingRecord: 'Clearing Record',
                    gameOver: 'Game Over!',
                    finalScore: 'Final Score',
                    playAgainPrompt: 'Play again to challenge for a higher score!',
                    replaySameSeed: 'Replay Same Round',
                    shareResult: 'Share Result',
                    copied: 'Copied to clipboard',
                    shareFailed: 'Share failed, please copy manually',
                    shareText: 'I\'m playing Grid Poker at https://poe.com/pokergrid with a good score of {score} points. The random seed is {seed}. Come play with me!',
                    comboClearing: '{count} patterns cleared! ({multiplier}× points)',
                    patternPoints: '{pattern}! +{points} pts',
                    cleared: 'Cleared',
                    singlePattern: 'Cleared {pattern} [{cards}] = {points} pts',
                    multiplePattern: '{count} patterns cleared! ({multiplier}) = {points} pts',
                    gameOverMessage: 'Game Over!',
                    // Card pattern names
                    'flush': 'Flush',
                    'straight': 'Straight',
                    'threeOfAKind': 'Three of a Kind',
                    'straightFlush': 'Straight Flush'
                },
                'fr': {
                    name: 'Français',
                    gameTitle: 'Poker Grille',
                    gameDescription: 'Formez Couleur (50pts), Suite (100pts), Brelan (100pts) ou Quinte Flush (200pts) pour éliminer lignes, colonnes ou diagonales',
                    comboDescription: 'Élimination simultanée : 2 motifs ×2, 3 motifs ×4, 4 motifs ×8',
                    remainingCards: 'Cartes restantes',
                    score: 'Score',
                    randomSeed: 'Graine aléatoire',
                    copy: 'Copier',
                    share: 'Partager',
                    restart: 'Recommencer',
                    newGame: 'Nouvelle partie',
                    enterSeed: 'Entrez une graine pour démarrer une partie spécifique',
                    start: 'Démarrer',
                    currentCard: 'Carte actuelle',
                    remainingDeck: 'Cartes restantes dans le paquet',
                    clearingRecord: 'Historique d\'élimination',
                    gameOver: 'Partie terminée !',
                    finalScore: 'Score final',
                    playAgainPrompt: 'Rejouez pour battre votre score !',
                    replaySameSeed: 'Rejouer même partie',
                    shareResult: 'Partager résultat',
                    copied: 'Copié dans le presse-papiers',
                    shareFailed: 'Échec du partage, veuillez copier manuellement',
                    shareText: 'Je joue à Poker Grille sur https://poe.com/pokergrid avec un bon score de {score} points. La graine aléatoire est {seed}. Venez jouer avec moi !',
                    comboClearing: '{count} motifs éliminés ! (points ×{multiplier})',
                    patternPoints: '{pattern} ! +{points} pts',
                    cleared: 'Éliminé',
                    singlePattern: 'Éliminé {pattern} [{cards}] = {points} pts',
                    multiplePattern: '{count} motifs éliminés ! ({multiplier}) = {points} pts',
                    gameOverMessage: 'Partie terminée !',
                    // Card pattern names
                    'flush': 'Couleur',
                    'straight': 'Suite',
                    'threeOfAKind': 'Brelan',
                    'straightFlush': 'Quinte Flush'
                },
                'de': {
                    name: 'Deutsch',
                    gameTitle: 'Raster-Poker',
                    gameDescription: 'Bilde Flush (50P), Straight (100P), Drilling (100P) oder Straight Flush (200P) um Reihen, Spalten oder Diagonalen zu entfernen',
                    comboDescription: 'Gleichzeitige Entfernung: 2 Muster ×2, 3 Muster ×4, 4 Muster ×8',
                    remainingCards: 'Verbleibende Karten',
                    score: 'Punkte',
                    randomSeed: 'Zufallsseed',
                    copy: 'Kopieren',
                    share: 'Teilen',
                    restart: 'Neustart',
                    newGame: 'Neues Spiel',
                    enterSeed: 'Seed eingeben, um bestimmtes Spiel zu starten',
                    start: 'Start',
                    currentCard: 'Aktuelle Karte',
                    remainingDeck: 'Verbleibende Karten im Stapel',
                    clearingRecord: 'Entfernungsprotokoll',
                    gameOver: 'Spiel beendet!',
                    finalScore: 'Endpunktzahl',
                    playAgainPrompt: 'Spiele erneut, um eine höhere Punktzahl zu erreichen!',
                    replaySameSeed: 'Gleiche Runde wiederholen',
                    shareResult: 'Ergebnis teilen',
                    copied: 'In die Zwischenablage kopiert',
                    shareFailed: 'Teilen fehlgeschlagen, bitte manuell kopieren',
                    shareText: 'Ich spiele Raster-Poker auf https://poe.com/pokergrid mit einer guten Punktzahl von {score}. Der Zufallsseed ist {seed}. Spiel mit mir!',
                    comboClearing: '{count} Muster entfernt! (Punkte ×{multiplier})',
                    patternPoints: '{pattern}! +{points} P',
                    cleared: 'Entfernt',
                    singlePattern: '{pattern} entfernt [{cards}] = {points} P',
                    multiplePattern: '{count} Muster entfernt! ({multiplier}) = {points} P',
                    gameOverMessage: 'Spiel beendet!',
                    // Card pattern names
                    'flush': 'Flush',
                    'straight': 'Straight',
                    'threeOfAKind': 'Drilling',
                    'straightFlush': 'Straight Flush'
                },
                'es': {
                    name: 'Español',
                    gameTitle: 'Póker de Cuadrícula',
                    gameDescription: 'Forma Color (50pts), Escalera (100pts), Trío (100pts) o Escalera de Color (200pts) para eliminar filas, columnas o diagonales',
                    comboDescription: 'Eliminación simultánea: 2 patrones ×2, 3 patrones ×4, 4 patrones ×8',
                    remainingCards: 'Cartas restantes',
                    score: 'Puntuación',
                    randomSeed: 'Semilla aleatoria',
                    copy: 'Copiar',
                    share: 'Compartir',
                    restart: 'Reiniciar',
                    newGame: 'Nuevo juego',
                    enterSeed: 'Introduce semilla para iniciar juego específico',
                    start: 'Iniciar',
                    currentCard: 'Carta actual',
                    remainingDeck: 'Cartas restantes en la baraja',
                    clearingRecord: 'Registro de eliminaciones',
                    gameOver: '¡Juego terminado!',
                    finalScore: 'Puntuación final',
                    playAgainPrompt: '¡Juega de nuevo para conseguir una puntuación más alta!',
                    replaySameSeed: 'Repetir misma ronda',
                    shareResult: 'Compartir resultado',
                    copied: 'Copiado al portapapeles',
                    shareFailed: 'Error al compartir, por favor copia manualmente',
                    shareText: 'Estoy jugando Póker de Cuadrícula en https://poe.com/pokergrid con una buena puntuación de {score} puntos. La semilla aleatoria es {seed}. ¡Ven a jugar conmigo!',
                    comboClearing: '¡{count} patrones eliminados! (puntos ×{multiplier})',
                    patternPoints: '¡{pattern}! +{points} pts',
                    cleared: 'Eliminado',
                    singlePattern: 'Eliminado {pattern} [{cards}] = {points} pts',
                    multiplePattern: '¡{count} patrones eliminados! ({multiplier}) = {points} pts',
                    gameOverMessage: '¡Juego terminado!',
                    // Card pattern names
                    'flush': 'Color',
                    'straight': 'Escalera',
                    'threeOfAKind': 'Trío',
                    'straightFlush': 'Escalera de Color'
                },
                'pt': {
                    name: 'Português',
                    gameTitle: 'Poker de Grade',
                    gameDescription: 'Forme Flush (50pts), Sequência (100pts), Trinca (100pts) ou Straight Flush (200pts) para limpar linhas, colunas ou diagonais',
                    comboDescription: 'Limpeza simultânea: 2 padrões ×2, 3 padrões ×4, 4 padrões ×8',
                    remainingCards: 'Cartas restantes',
                    score: 'Pontuação',
                    randomSeed: 'Semente aleatória',
                    copy: 'Copiar',
                    share: 'Compartilhar',
                    restart: 'Reiniciar',
                    newGame: 'Novo jogo',
                    enterSeed: 'Digite uma semente para iniciar um jogo específico',
                    start: 'Iniciar',
                    currentCard: 'Carta atual',
                    remainingDeck: 'Cartas restantes no baralho',
                    clearingRecord: 'Registro de limpezas',
                    gameOver: 'Fim de jogo!',
                    finalScore: 'Pontuação final',
                    playAgainPrompt: 'Jogue novamente para um desafio de pontuação mais alta!',
                    replaySameSeed: 'Repetir mesma rodada',
                    shareResult: 'Compartilhar resultado',
                    copied: 'Copiado para a área de transferência',
                    shareFailed: 'Falha ao compartilhar, por favor copie manualmente',
                    shareText: 'Estou jogando Poker de Grade em https://poe.com/pokergrid com uma boa pontuação de {score} pontos. A semente aleatória é {seed}. Venha jogar comigo!',
                    comboClearing: '{count} padrões limpos! (pontos ×{multiplier})',
                    patternPoints: '{pattern}! +{points} pts',
                    cleared: 'Limpo',
                    singlePattern: 'Limpo {pattern} [{cards}] = {points} pts',
                    multiplePattern: '{count} padrões limpos! ({multiplier}) = {points} pts',
                    gameOverMessage: 'Fim de jogo!',
                    // Card pattern names
                    'flush': 'Flush',
                    'straight': 'Sequência',
                    'threeOfAKind': 'Trinca',
                    'straightFlush': 'Straight Flush'
                }
            };
            
            // Default language
            let currentLanguage = 'zh-CN';
            
            // Try to detect user's browser language
            function detectBrowserLanguage() {
                const browserLang = navigator.language || navigator.userLanguage;
                const shortLang = browserLang.split('-')[0];
                
                // Check if we have an exact match
                if (LANGUAGES[browserLang]) {
                    return browserLang;
                }
                
                // Check for language matches
                for (const lang in LANGUAGES) {
                    if (lang.startsWith(shortLang)) {
                        return lang;
                    }
                }
                
                // Default to Chinese if no match
                return 'zh-CN';
            }
            
            // Initialize language selector
            function initLanguageSelector() {
                const selector = document.getElementById('language-selector');
                
                // Add options for each language
                for (const lang in LANGUAGES) {
                    const option = document.createElement('option');
                    option.value = lang;
                    option.textContent = LANGUAGES[lang].name;
                    selector.appendChild(option);
                }
                
                // Set initial language
                currentLanguage = detectBrowserLanguage();
                selector.value = currentLanguage;
                
                // Apply translations
                applyTranslations();
                
                // Add event listener for language change
                selector.addEventListener('change', (event) => {
                    currentLanguage = event.target.value;
                    applyTranslations();
                });
            }
            
            // Get translation for a key
            function t(key, replacements = {}) {
                let text = LANGUAGES[currentLanguage][key] || LANGUAGES['en'][key] || key;
                
                // Apply replacements
                for (const [placeholder, value] of Object.entries(replacements)) {
                    text = text.replace(`{${placeholder}}`, value);
                }
                
                return text;
            }
            
            // Apply translations to all elements with data-i18n attribute
            function applyTranslations() {
                document.querySelectorAll('[data-i18n]').forEach(element => {
                    const key = element.getAttribute('data-i18n');
                    element.textContent = t(key);
                });
                
                // Apply placeholder translations
                document.querySelectorAll('[data-i18n-placeholder]').forEach(element => {
                    const key = element.getAttribute('data-i18n-placeholder');
                    element.placeholder = t(key);
                });
                
                // Update dynamic content if needed
                updateDynamicContent();
            }
            
            // Update dynamic content that needs translation
            function updateDynamicContent() {
                // This function can be expanded as needed
            }
            
            // Check for dark mode preference
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                document.documentElement.classList.add('dark');
            }
            
            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
                if (event.matches) {
                    document.documentElement.classList.add('dark');
                } else {
                    document.documentElement.classList.remove('dark');
                }
            });

            // Game constants
            const SUITS = ['heart', 'diamond', 'spade', 'club'];
            const SUIT_SYMBOLS = {
                'heart': '♥',
                'diamond': '♦',
                'spade': '♠',
                'club': '♣'
            };
            const RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
            const RANK_VALUES = {
                'A': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7,
                '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13
            };
            
            const SCORE_VALUES = {
                'flush': 50,        // 同花
                'straight': 100,    // 顺子
                'threeOfAKind': 100,// 三条
                'straightFlush': 200// 同花顺
            };
            
            // 特殊加分规则
            const COMBO_MULTIPLIERS = {
                2: 2,  // 双消除 2倍分数
                3: 4,  // 三连消除 4倍分数
                4: 8   // 四连消除 8倍分数
            };

            // Game state
            let deck = [];
            let grid = Array(9).fill(null);
            let currentCard = null;
            let score = 0;
            let currentSeed = '';
            let gameOver = false;
            let seededRandom = null;

            // DOM elements
            const gridContainer = document.querySelector('.grid');
            const scoreDisplay = document.getElementById('score');
            const remainingCardsDisplay = document.getElementById('remaining-cards');
            const currentCardElement = document.getElementById('current-card');
            const seedDisplay = document.getElementById('seed-display');
            const gameMessage = document.getElementById('game-message');
            const resultModal = document.getElementById('result-modal');
            const finalScoreDisplay = document.getElementById('final-score');
            const newGameBtn = document.getElementById('new-game-btn');
            const copySeedBtn = document.getElementById('copy-seed');
            const seedInput = document.getElementById('seed-input');
            const startFromSeedBtn = document.getElementById('start-from-seed');
            const playAgainBtn = document.getElementById('play-again');
            const toastElement = document.getElementById('toast');

            // Create a seeded random number generator
            function createSeededRandom(seed) {
                // Simple hash function for seed
                let hash = Array.from(seed).reduce((acc, char) => {
                    return ((acc << 5) - acc) + char.charCodeAt(0) | 0;
                }, 0);
                
                return function() {
                    const x = Math.sin(hash++) * 10000;
                    return x - Math.floor(x);
                };
            }

            // Initialize the game board
            function initializeGrid() {
                gridContainer.innerHTML = '';
                
                for (let i = 0; i < 9; i++) {
                    const cell = document.createElement('div');
                    cell.classList.add('card', 'w-16', 'h-24', 'md:w-20', 'md:h-30', 'bg-white', 'dark:bg-gray-800', 'border', 'border-gray-300', 'dark:border-gray-700', 'rounded-lg', 'shadow-md', 'flex', 'items-center', 'justify-center', 'cursor-pointer', 'hover:border-primary', 'dark:hover:border-primary');
                    cell.dataset.index = i;
                    
                    // Add click event
                    cell.addEventListener('click', () => {
                        if (!gameOver && currentCard && !grid[i]) {
                            placeCard(i);
                        }
                    });
                    
                    gridContainer.appendChild(cell);
                }
            }

            // Create and shuffle deck
            function createDeck() {
                const deck = [];
                
                for (const suit of SUITS) {
                    for (const rank of RANKS) {
                        deck.push({ suit, rank });
                    }
                }
                
                return deck;
            }

            // Fisher-Yates shuffle using seeded random
            function shuffleDeck(deck) {
                const shuffled = [...deck];
                
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(seededRandom() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                
                return shuffled;
            }

            // Draw the next card from the deck
            function drawCard() {
                if (deck.length === 0) {
                    return null;
                }
                
                remainingCardsDisplay.textContent = deck.length - 1;
                return deck.pop();
            }

            // Display a card in the current card slot
            function displayCurrentCard(card) {
                if (!card) {
                    currentCardElement.innerHTML = `
                        <div class="card-inner">
                            <div class="card-front flex items-center justify-center">
                                <span>-</span>
                            </div>
                        </div>
                    `;
                    return;
                }
                
                const { suit, rank } = card;
                currentCardElement.innerHTML = `
                    <div class="card-inner">
                        <div class="card-front flex flex-col items-center justify-center">
                            <div class="text-xs md:text-sm">${rank}</div>
                            <div class="${suit} text-lg md:text-xl">${SUIT_SYMBOLS[suit]}</div>
                        </div>
                    </div>
                `;
            }

            // Place a card on the grid
            function placeCard(index) {
                if (grid[index] || !currentCard) {
                    return;
                }
                
                grid[index] = currentCard;
                const cell = gridContainer.children[index];
                const { suit, rank } = currentCard;
                
                cell.innerHTML = `
                    <div class="card-front flex flex-col items-center justify-center card-fade-in">
                        <div class="text-xs md:text-sm">${rank}</div>
                        <div class="${suit} text-lg md:text-xl">${SUIT_SYMBOLS[suit]}</div>
                    </div>
                `;
                
                cell.classList.remove('hover:border-primary', 'dark:hover:border-primary', 'cursor-pointer');
                
                // Check for completed patterns
                checkPatterns();
                
                // Draw the next card
                currentCard = drawCard();
                displayCurrentCard(currentCard);
                
                // Update card counter
                updateCardCounter();
                
                // Check if the game is over
                checkGameOver();
            }

            // Check for completed patterns (rows, columns, diagonals)
            function checkPatterns() {
                const patterns = [
                    // Rows
                    [0, 1, 2],
                    [3, 4, 5],
                    [6, 7, 8],
                    // Columns
                    [0, 3, 6],
                    [1, 4, 7],
                    [2, 5, 8],
                    // Diagonals
                    [0, 4, 8],
                    [2, 4, 6]
                ];
                
                const validPatterns = [];
                
                // Collect all valid patterns
                for (const pattern of patterns) {
                    if (pattern.every(index => grid[index])) {
                        const cards = pattern.map(index => grid[index]);
                        const patternType = getPatternType(cards);
                        
                        if (patternType) {
                            validPatterns.push({ pattern, patternType });
                        }
                    }
                }
                
                // If we have valid patterns, process them
                if (validPatterns.length > 0) {
                    processPatterns(validPatterns);
                }
            }
            
            // Process multiple patterns at once if needed
            function processPatterns(validPatterns) {
                // 先计算所有牌型的基础分数总和
                let baseTotalPoints = 0;
                let allCellsToRemove = new Set();
                let patternDetails = [];
                
                // 收集所有牌型的基础分和卡牌
                for (const { pattern, patternType } of validPatterns) {
                    const basePoints = SCORE_VALUES[patternType];
                    baseTotalPoints += basePoints;
                    
                    // 获取此牌型中的卡牌用于日志记录
                    const cardsInPattern = pattern.map(index => grid[index]);
                    
                    // 添加单元格到清除集合
                    pattern.forEach(index => allCellsToRemove.add(index));
                    
                    // 先存储基础信息（之后会更新分数）
                    patternDetails.push({
                        type: patternType,
                        basePoints: basePoints,
                        cards: cardsInPattern
                    });
                }
                
                // 根据连消次数确定乘数
                let multiplier = 1;
                if (validPatterns.length === 2) {
                    multiplier = COMBO_MULTIPLIERS[2]; // 双消除 x2
                } else if (validPatterns.length === 3) {
                    multiplier = COMBO_MULTIPLIERS[3]; // 三连消除 x4
                } else if (validPatterns.length >= 4) {
                    multiplier = COMBO_MULTIPLIERS[4]; // 四连消除 x8
                }
                
                // 计算最终总分（基础分数之和 × 乘数）
                const totalPoints = baseTotalPoints * multiplier;
                
                // 更新每个牌型的显示分数（用于日志显示）
                patternDetails = patternDetails.map(pattern => {
                    // 计算此牌型贡献的最终分数：基础分数在总分中的占比 × 最终总分
                    const ratio = pattern.basePoints / baseTotalPoints;
                    const points = Math.round(totalPoints * ratio);
                    
                    return {
                        ...pattern,
                        points: points  // 更新为贡献的最终分数
                    };
                });
                
                // Update score
                score += totalPoints;
                scoreDisplay.textContent = score;
                
                // Create message about patterns and points
                let comboText = '';
                let gameMessageText = '';
                
                if (validPatterns.length >= 2) {
                    comboText = t('comboClearing', {count: validPatterns.length, multiplier: multiplier});
                    gameMessageText = `${comboText} +${totalPoints}`;
                } else {
                    const patternType = validPatterns[0].patternType;
                    gameMessageText = t('patternPoints', {pattern: t(patternType), points: totalPoints});
                }
                
                // Show message
                gameMessage.textContent = gameMessageText;
                gameMessage.classList.add('text-primary', 'font-bold');
                
                // Add log entry
                addLogEntry(patternDetails, validPatterns.length, totalPoints);
                
                // Clear cells with animation
                const cellsToRemove = Array.from(allCellsToRemove);
                for (const index of cellsToRemove) {
                    const cell = gridContainer.children[index];
                    
                    // 添加安全的元素淡出动画
                    try {
                        // 使用querySelector而不是firstChild，更明确地选择元素
                        const cardElement = cell.querySelector('.card-front');
                        if (cardElement) {
                            // 移除淡入动画类并添加淡出动画类
                            cardElement.classList.remove('card-fade-in');
                            cardElement.classList.add('card-fade-out');
                        }
                    } catch (e) {
                        console.error("Animation error:", e);
                    }
                    
                    // 设置延时清空单元格
                    setTimeout(() => {
                        cell.innerHTML = '';
                        cell.classList.add('hover:border-primary', 'dark:hover:border-primary', 'cursor-pointer');
                        grid[index] = null;
                        
                        // 更新记牌器状态，确保清除牌后记牌器也更新
                        updateCardCounter();
                    }, 300);
                }
                
                // Reset message after a delay
                setTimeout(() => {
                    gameMessage.textContent = '';
                    gameMessage.classList.remove('text-primary', 'font-bold');
                }, 2000);
            }
            
            // Add a log entry about pattern clearing
            function addLogEntry(patternDetails, patternCount, totalPoints) {
                const gameLog = document.querySelector('#game-log div');
                const logEntry = document.createElement('div');
                
                // Format card display for log
                function formatCards(cards) {
                    return cards.map(card => {
                        let colorClass = '';
                        if (card.suit === 'heart') {
                            colorClass = 'text-red-600 dark:text-red-400'; // 红桃红色
                        } else if (card.suit === 'diamond') {
                            colorClass = 'text-orange-500 dark:text-orange-300'; // 方块橙色
                        } else if (card.suit === 'spade') {
                            colorClass = 'text-purple-600 dark:text-purple-400'; // 黑桃紫色
                        }
                        return `<span class="${colorClass}">${card.rank}${SUIT_SYMBOLS[card.suit]}</span>`;
                    }).join(' ');
                }
                
                // Format details based on number of patterns
                if (patternCount > 1) {
                    // Multiple pattern details
                    let patternsHtml = patternDetails.map(p => {
                        return `<div class="ml-1 mt-1"><span class="font-semibold text-primary">${t(p.type)}</span> [${formatCards(p.cards)}] = <span class="font-bold">${p.points}${t('score').substring(0,1)}</span></div>`;
                    }).join('');
                    
                    let multiplierText;
                    if (patternCount >= 4) {
                        multiplierText = '8×';
                    } else if (patternCount === 3) {
                        multiplierText = '4×';
                    } else {
                        multiplierText = '2×';
                    }
                    
                    logEntry.innerHTML = t('multiplePattern', {
                        count: patternCount,
                        multiplier: multiplierText,
                        points: totalPoints
                    });
                    
                    logEntry.innerHTML += patternsHtml;
                } else {
                    // Single pattern
                    const pattern = patternDetails[0];
                    logEntry.innerHTML = t('singlePattern', {
                        pattern: t(pattern.type),
                        cards: formatCards(pattern.cards),
                        points: pattern.points
                    });
                }
                
                logEntry.classList.add('text-sm', 'py-1', 'border-b', 'border-gray-200', 'dark:border-gray-700', 'pb-2', 'mb-1');
                gameLog.prepend(logEntry);
            }

            // Identify the pattern type if any
            function getPatternType(cards) {
                // Check for straight flush (同花顺)
                if (isStraight(cards) && isFlush(cards)) {
                    return 'straightFlush';
                }
                
                // Check for flush (同花)
                if (isFlush(cards)) {
                    return 'flush';
                }
                
                // Check for straight (顺子)
                if (isStraight(cards)) {
                    return 'straight';
                }
                
                // Check for three of a kind (三条)
                if (isThreeOfAKind(cards)) {
                    return 'threeOfAKind';
                }
                
                return null;
            }

            // Check if cards form a flush (same suit)
            function isFlush(cards) {
                const firstSuit = cards[0].suit;
                return cards.every(card => card.suit === firstSuit);
            }

            // Check if cards form a straight (sequential values)
            function isStraight(cards) {
                const values = cards.map(card => RANK_VALUES[card.rank]).sort((a, b) => a - b);
                
                // Special case for A-K-Q
                if (values[0] === 1 && values[1] === 12 && values[2] === 13) {
                    return true;
                }
                
                // Special case for A-2-3
                if (values[0] === 1 && values[1] === 2 && values[2] === 3) {
                    return true;
                }
                
                // Check for sequential values
                return values[1] === values[0] + 1 && values[2] === values[1] + 1;
            }

            // Check if cards form three of a kind (same rank)
            function isThreeOfAKind(cards) {
                const firstRank = cards[0].rank;
                return cards.every(card => card.rank === firstRank);
            }

            // 检查是否有可消除的牌型
            function hasValidPatterns() {
                const patterns = [
                    // Rows
                    [0, 1, 2],
                    [3, 4, 5],
                    [6, 7, 8],
                    // Columns
                    [0, 3, 6],
                    [1, 4, 7],
                    [2, 5, 8],
                    // Diagonals
                    [0, 4, 8],
                    [2, 4, 6]
                ];
                
                // 检查是否存在有效的模式
                for (const pattern of patterns) {
                    if (pattern.every(index => grid[index])) {
                        const cards = pattern.map(index => grid[index]);
                        const patternType = getPatternType(cards);
                        
                        if (patternType) {
                            return true; // 找到一个可消除的牌型
                        }
                    }
                }
                
                return false; // 没有找到可消除的牌型
            }
            
            // Check if the game is over
            function checkGameOver() {
                // 如果牌已用完且没有当前牌，或者格子已填满且没有可消除的牌型，则游戏结束
                const gridIsFull = grid.every(cell => cell !== null);
                const noMoreCards = deck.length === 0 && !currentCard;
                
                // 如果格子已满，但还有可消除的牌型，那么游戏还没结束
                if (gridIsFull && hasValidPatterns()) {
                    return; // 仍有可消除的牌型，游戏继续
                }
                
                // 如果牌用完或格子填满且无法消除，则游戏结束
                if (noMoreCards || gridIsFull) {
                    gameOver = true;
                    
                    // Show result modal
                    finalScoreDisplay.textContent = score;
                    resultModal.classList.remove('hidden');
                    
                    // Display game over message
                    gameMessage.textContent = t('gameOverMessage');
                }
            }

            // 初始化记牌器
            function initializeCardCounter() {
                const cardCounter = document.getElementById('card-counter');
                cardCounter.innerHTML = '';
                
                // 添加花色标题行
                const headerRow = document.createElement('div');
                headerRow.classList.add('contents');
                
                // 添加花色标题 - 按黑红梅方顺序排列
                const suits = ['spade', 'heart', 'club', 'diamond'];
                const suitNames = {
                    'spade': '♠',  // 紫色
                    'heart': '♥',  // 红色
                    'club': '♣',   // 黑色
                    'diamond': '♦'  // 橙色
                };
                
                suits.forEach(suit => {
                    const suitHeader = document.createElement('div');
                    suitHeader.classList.add('font-bold', 'mb-1', suit);
                    suitHeader.textContent = suitNames[suit];
                    headerRow.appendChild(suitHeader);
                });
                
                cardCounter.appendChild(headerRow);
                
                // 添加牌面 - 从A到2，倒序排列
                const ranks = ['A', 'K', 'Q', 'J', '10', '9', '8', '7', '6', '5', '4', '3', '2'];
                
                // 为每个牌面创建一行
                ranks.forEach(rank => {
                    const rankRow = document.createElement('div');
                    rankRow.classList.add('contents');
                    
                    // 为每个花色创建一个单元格
                    suits.forEach(suit => {
                        const card = document.createElement('div');
                        card.classList.add('text-xs', 'py-1', suit);
                        card.id = `card-${suit}-${rank}`;
                        card.dataset.rank = rank; // 保存原始牌面值，用于重置显示
                        card.textContent = rank;
                        rankRow.appendChild(card);
                    });
                    
                    cardCounter.appendChild(rankRow);
                });
            }
            
            // 更新记牌器显示
            function updateCardCounter() {
                // 首先重置所有牌的可见性
                document.querySelectorAll('#card-counter [id^="card-"]').forEach(card => {
                    card.textContent = card.dataset.rank; // 恢复所有牌的显示
                });
                
                // 处理所有牌
                for (const suit of SUITS) {
                    for (const rank of RANKS) {
                        // 检查是否还有这张牌在牌组中
                        const isInDeck = deck.some(card => card.suit === suit && card.rank === rank);
                        
                        // 如果不在牌组中(已经被抽出)，或者是当前牌或九宫格区域的牌，都应从记牌器中移除
                        if (!isInDeck || 
                            (currentCard && currentCard.suit === suit && currentCard.rank === rank) || 
                            grid.some(card => card && card.suit === suit && card.rank === rank)) {
                            
                            // 从记牌器中移除此牌
                            const cardElement = document.getElementById(`card-${suit}-${rank}`);
                            if (cardElement) {
                                cardElement.textContent = ''; // 清空文字，不显示
                            }
                        }
                    }
                }
            }
            
            // Show toast notification
            function showToast(message) {
                toastElement.textContent = message;
                toastElement.classList.add('opacity-100');
                
                setTimeout(() => {
                    toastElement.classList.remove('opacity-100');
                }, 2000);
            }
            
            // Share game with others
            function shareGame() {
                const shareText = t('shareText', {score: score, seed: currentSeed});
                
                navigator.clipboard.writeText(shareText).then(() => {
                    showToast(t('copied'));
                }).catch(err => {
                    console.error('Share failed:', err);
                    showToast(t('shareFailed'));
                });
            }
            
            // Start a new game with an optional seed
            function startGame(seed = null) {
                // Generate or use provided seed
                currentSeed = seed || crypto.randomUUID();
                seedDisplay.textContent = currentSeed;
                
                // Initialize seeded random
                seededRandom = createSeededRandom(currentSeed);
                
                // Reset game state
                grid = Array(9).fill(null);
                score = 0;
                gameOver = false;
                
                // Create and shuffle deck
                deck = createDeck();
                deck = shuffleDeck(deck);
                
                // Update displays
                scoreDisplay.textContent = score;
                remainingCardsDisplay.textContent = deck.length;
                
                // Draw first card
                currentCard = drawCard();
                displayCurrentCard(currentCard);
                
                // Initialize grid
                initializeGrid();
                
                // Initialize and update card counter
                initializeCardCounter();
                updateCardCounter();
                
                // Hide modal if visible
                resultModal.classList.add('hidden');
                
                // Reset message
                gameMessage.textContent = '';
                gameMessage.classList.remove('text-primary', 'font-bold');
            }
            
            // Event listeners
            function setupEventListeners() {
                newGameBtn.addEventListener('click', () => {
                    // 清空游戏日志（只在开始新游戏时清空，而不是在游戏结束时）
                    const gameLog = document.querySelector('#game-log div');
                    gameLog.innerHTML = '';
                    
                    startGame();
                });
                
                // 添加骰子按钮的事件监听器，用于生成新的随机种子，但使用相同的游戏
                document.getElementById('random-seed').addEventListener('click', () => {
                    // 生成一个新的随机种子
                    const newSeed = crypto.randomUUID();
                    // 将它添加到输入框中
                    seedInput.value = newSeed;
                    // 高亮显示输入框，以便用户注意到变化
                    seedInput.classList.add('bg-yellow-50', 'dark:bg-yellow-900');
                    setTimeout(() => {
                        seedInput.classList.remove('bg-yellow-50', 'dark:bg-yellow-900');
                    }, 1000);
                });
                
                copySeedBtn.addEventListener('click', () => {
                    navigator.clipboard.writeText(currentSeed).then(() => {
                        showToast(t('copied'));
                    });
                });
                
                // 分享当前游戏
                document.getElementById('share-game').addEventListener('click', shareGame);
                
                // 分享游戏结果
                document.getElementById('share-result').addEventListener('click', shareGame);
                
                startFromSeedBtn.addEventListener('click', () => {
                    const seed = seedInput.value.trim();
                    if (seed) {
                        // 清空游戏日志（只在开始新游戏时清空）
                        const gameLog = document.querySelector('#game-log div');
                        gameLog.innerHTML = '';
                        
                        startGame(seed);
                        seedInput.value = '';
                    }
                });
                
                playAgainBtn.addEventListener('click', () => {
                    // 清空游戏日志（只在开始新游戏时清空）
                    const gameLog = document.querySelector('#game-log div');
                    gameLog.innerHTML = '';
                    
                    startGame(); // 开始新游戏，随机种子
                });
                
                // 添加"重玩本局"按钮的事件监听器（游戏结束弹窗中的）
                document.getElementById('replay-same-seed').addEventListener('click', () => {
                    // 清空游戏日志
                    const gameLog = document.querySelector('#game-log div');
                    gameLog.innerHTML = '';
                    
                    // 使用相同的种子重新开始游戏
                    startGame(currentSeed);
                });
                
                // 添加顶部"重开"按钮的事件监听器
                document.getElementById('restart-game').addEventListener('click', () => {
                    // 清空游戏日志
                    const gameLog = document.querySelector('#game-log div');
                    gameLog.innerHTML = '';
                    
                    // 使用相同的种子重新开始游戏
                    startGame(currentSeed);
                });
            }

            // Initialize game
            function init() {
                initLanguageSelector();
                setupEventListeners();
                startGame();
            }

            // Start the game when page loads
            window.addEventListener('DOMContentLoaded', init);
        </script>
    </div>
</body>
</html>
